<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
//选择排序
// 每一趟在n-i+1(i=1,2,...,n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。具体来说，假设长度为n的数组arr，要按照从小到大排序，那么先从n个数字中找到最小值min1，如果最小值min1的位置不在数组的最左端(也就是min1不等于arr[0])，则将最小值min1和arr[0]交换，接着在剩下的n-1个数字中找到最小值min2，如果最小值min2不等于arr[1]，则交换这两个数字，依次类推，直到数组arr有序排列。算法的时间复杂度为O(n^2)。

// var arr=[1,5,4,6,7,3,2,8,9];
// console.log(selectionSort(arr));

// function selectionSort(arr){
//   for(var i=0;i<arr.length;i++){
//     var index=i;
//     for(var j=i+1;j<arr.length;j++){
//       if(arr[j]<arr[index]){
//         index=j 
//       } 
//       if(index==i)
//       continue;
//       else{
//         var temp=arr[index];
//         arr[index]=arr[i];
//         arr[i]=temp;
//       }
//     }
//     console.log(arr);
//   }
//   // return arr;
// }

//插入牌堆
// 插入排序的基本思想就是将无序序列插入到有序序列中。例如要将数组arr=[4,2,8,0,5,1]排序，可以将4看做是一个有序序列(图中用蓝色标出)，将[2,8,0,5,1]看做一个无序序列。无序序列中2比4小，于是将2插入到4的左边，此时有序序列变成了[2,4]，无序序列变成了[8,0,5,1]。无序序列中8比4大，于是将8插入到4的右边，有序序列变成了[2,4,8],无序序列变成了[0,5,1]。以此类推，最终数组按照从小到大排序。该算法的时间复杂度为O(n^2)。



var arr=[4,2,8,0,5,1];
// console.log(insertSort(arr));
insertSort(arr)
// function insertSort(arr){
//   for(var i=1;i<arr.length;i++){
//     var j;
//     if(arr[i]<arr[i-1]){
//       var temp=arr[i];
//       for(var j=i-1;j>=0 && temp<arr[j];j--){
//         arr[j+1]=arr[j];
//       }
//       arr[j+1]=temp;
//       console.log(arr);
//     }
//   }
//   // return arr;
// }
function insertSort(arr){
for(var i=1;i<arr.length;i++){
  if(arr[i]<arr[i-1]){
    var temp=arr[i];
    for(var j=i-1;j>=0 && temp<arr[j];j--){
      arr[j+1]=arr[j];
    }
    arr[j+1]=temp;
    console.log(arr);
}
  }
 
}


  </script>
</body>

</html>